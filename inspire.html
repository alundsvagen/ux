<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Inspire Me — vibes that give me joy.</title>
  <link rel="icon" type="image/png" href="inspire.png" />
  <link href="https://fonts.cdnfonts.com/css/garet" rel="stylesheet">
  <link href="https://fonts.cdnfonts.com/css/helios" rel="stylesheet">
  <!-- Bootstrap Icons (for pin/x/check) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">

  <style>
    :root {
      --bg: #f2f2f2;
      --text: #0b0b0b;
      --accent: #ff6ea8;
      --grid-color: rgba(0, 170, 255, 0.25);
    }

    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      font-family: 'Garet', sans-serif;
      overflow: hidden;
    }

    .container {
      min-height: 100dvh;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: clamp(14px, 2vw, 28px);
      max-width: 1280px;
      margin-inline: auto;
      width: 100%;
      font-family: 'Helios', sans-serif;
      z-index: 10;
      position: relative;
    }

    .brand { display: inline-flex; flex-direction: column; gap: 2px; line-height: 1.1; text-transform: uppercase; font-weight: 600; letter-spacing: 0.06em; font-size: clamp(11px, 1.2vw, 14px); }
    .brand a, .brand small a { color: var(--text); text-decoration: underline; text-decoration-thickness: 1px; text-underline-offset: 2px; }

    .contact-btn {
      background: transparent; color: var(--text); border: 2px solid var(--text);
      padding: .55rem 1.1rem; border-radius: 6px; font-family: 'Helios', sans-serif; font-weight: 700;
      letter-spacing: 0.05em; text-transform: uppercase; font-size: clamp(11px, 1.2vw, 13px);
      text-decoration: none; transition: transform 120ms ease, background-color 120ms ease, color 120ms ease;
    }
    .contact-btn:hover { transform: translateY(-1px); }

    .hero { position: relative; display: grid; place-items: center; padding: clamp(28px, 6vw, 64px); overflow: hidden; }
    .hero-inner {
      position: relative; z-index: 2; text-align: center; max-width: 1100px; margin-inline: auto; display: grid; place-items: center;
      animation: fadeOut 1s ease 2s forwards; /* fade out after 2s */
    }

    .glow {
      position: absolute; left: 50%; top: 52%; transform: translate(-50%, -50%);
      width: min(140vmin, 1100px); height: min(140vmin, 1100px); border-radius: 50%;
      background: radial-gradient(circle, rgba(255,154,196,.60) 0%, rgba(255,154,196,.35) 34%, rgba(255,154,196,.16) 62%, rgba(255,154,196,.06) 78%, rgba(255,154,196,0) 100%);
      filter: blur(10px); z-index: 1; animation: floatGlow 28s ease-in-out infinite alternate; pointer-events: none;
    }
    @keyframes floatGlow {
      0% { transform: translate(-2%, -4%) scale(1); opacity:.9; }
      50%{ transform: translate(2%, 3%) scale(1.03); opacity:1; }
      100%{ transform: translate(-2%, -4%) scale(1); opacity:.9; }
    }

    .kicker { font-family: 'Helios', sans-serif; font-size: clamp(18px, 2.2vw, 34px); letter-spacing: 0.07em; text-transform: uppercase; font-weight: 500; margin-bottom: clamp(18px, 3vw, 24px); }
    .headline { margin: 0; font-weight: 700; line-height: .96; font-size: clamp(40px, 8.4vw, 128px); font-family: 'Garet', sans-serif; }
    .headline .line { display:block; } .headline .tight{ margin-top: clamp(8px,1vw,10px); }

    /* Vector grid background that fades in */
    .grid-fade {
      position: absolute; inset: 0; z-index: 0; background-color: #fff;
      background-image:
        linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
        linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
      background-size: 40px 40px;
      opacity: 0; animation: fadeIn 2s ease 2.5s forwards;
    }

    @keyframes fadeOut { to { opacity: 0; transform: translateY(-20px); pointer-events: none; } }
    @keyframes fadeIn  { to { opacity: 1; } }

    /* ===== Floating Blob + Controls ===== */
    .blob-wrap {
      position: absolute;
      width: clamp(160px, 22vmin, 320px);
      aspect-ratio: 1 / 1;
      z-index: 3;           /* above grid and glow, below header */
      left: 10vw; top: 55vh; /* starting spot */
      transform: translate(-50%, -50%);
      cursor: grab;
      transition: filter 160ms ease;
    }
    .blob-wrap:active { cursor: grabbing; }
    .blob {
      width: 100%; height: 100%;
      display: block; user-select: none; pointer-events: none; /* img itself isn’t clickable; controls are */
      filter: drop-shadow(0 8px 16px rgba(0,0,0,.15));
    }

    /* Controls (appear on hover) */
    .controls {
      position: absolute; top: -10px; right: -10px; display: flex; gap: 6px;
      background: rgba(255,255,255,.85); padding: 6px; border-radius: 10px;
      box-shadow: 0 6px 14px rgba(0,0,0,.14), 0 1px 0 rgba(0,0,0,.06) inset;
      opacity: 0; pointer-events: none; transform: translateY(-6px);
      transition: opacity 160ms ease, transform 160ms ease;
    }
    .blob-wrap:hover .controls { opacity: 1; pointer-events: auto; transform: none; }

    .btn-icon {
      width: 28px; height: 28px; border: none; border-radius: 6px; display: grid; place-items: center;
      background: #fff; color: #000; cursor: pointer; font-size: 18px;
      box-shadow: 0 1px 0 rgba(0,0,0,.06) inset;
      transition: transform 100ms ease, background 120ms ease;
    }
    .btn-icon:hover { transform: translateY(-1px); }
    .btn-icon:active { transform: translateY(0); }
    .btn-pin.active { background:#ffe88c; }           /* pinned state hint */
    .btn-x { color:#000; }
    .btn-check { color:#0dbb5f; }

    /* Particle basics (explosion / confetti) */
    .particle, .confetti {
      position: fixed; pointer-events: none; z-index: 4;
      will-change: transform, opacity;
    }

    @media (max-width: 600px) {
      header { justify-content: space-between; align-items: center; }
      .brand { align-items: flex-start; }
      .contact-btn { border-width: 1.5px; padding: .5rem .9rem; }
      .hero { min-height: 100dvh; place-items: start center; padding-top: 0; }
      .hero-inner { margin-top: clamp(56px, 12vh, 120px); }
      .glow { width: 120vmin; height: 120vmin; top: 52%; }
      .headline { font-size: clamp(36px, 10vw, 56px); line-height: 1; }
    }

    @media (prefers-reduced-motion: reduce) {
      .glow { animation: none; }
      .hero-inner, .grid-fade { animation: none; opacity: 1; }
    }
    
  </style>

  <style>
  #blobLayer { position: absolute; inset: 0; z-index: 3; pointer-events: none; }
  /* allow clicks on controls only */
  #blobLayer .controls, #blobLayer .btn-icon { pointer-events: auto; }

  /* gentle rotation that each blob gets with a random duration */
  @keyframes slowSpin { from { rotate: 0deg; } to { rotate: 360deg; } }

  /* entrance */
  .blob-wrap.entering { 
    animation: blobIn 600ms cubic-bezier(.2,.8,.2,1);
  }
  @keyframes blobIn {
    from { transform: translate(-50%,-50%) scale(.85); opacity: 0; }
    to   { transform: translate(-50%,-50%) scale(1);   opacity: 1; }
  }
  </style>
  
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <a href="https://alexandrapgrisanti.com/">ALEXANDRA P. GRISANTI</a>
        <small><a href="https://alexandrapgrisanti.com/">STOCKHOLM</a></small>
      </div>
      <a class="contact-btn" href="https://form.fillout.com/t/8jvkJJMYo7us">Contact</a>
    </header>

    <main class="hero">
      <div class="hero-inner">
        <div class="glow" aria-hidden="true"></div>
        <div class="kicker">Inspire Me</div>
        <h1 class="headline">
          <span class="line">vibes that give</span>
          <span class="line tight">me joy.</span>
        </h1>
      </div>
      <div class="grid-fade"></div>

    <!-- place this inside <main class="hero">, after .grid-fade -->
    <div id="blobLayer" aria-hidden="true"></div>

      <!-- Floating blob with hover controls -->
      <div class="blob-wrap" id="blob">
        <img class="blob" src="blob.svg" alt="floating blob" draggable="false" />
        <div class="controls">
          <button class="btn-icon btn-pin" id="btnPin" title="Pin / Unpin"><i class="bi bi-pin-angle-fill"></i></button>
          <button class="btn-icon btn-x" id="btnX" title="Explode"><i class="bi bi-x-circle"></i></button>
          <button class="btn-icon btn-check" id="btnCheck" title="Celebrate"><i class="bi bi-check-circle-fill"></i></button>
        </div>
      </div>
    </main>
  </div>

<script>
(() => {
  const LAYER = document.getElementById('blobLayer');

  // 1) Point to your 30 SVGs
  const SOURCES = Array.from({length: 30}, (_, i) => `blobs/blob${i+1}.svg`);

  // 2) Config
  const MAX_ON_SCREEN = 5;
  const BASE_SPEED = 35;            // px/sec
  const BOOST_MULT = 2.2;           // when green check is pressed
  const LIFETIME_MS = [20000, 35000]; // auto-despawn window (20–35s) if not pinned
  const EDGE_PAD = 24;

  // 3) State
  const queue = [...SOURCES];          // simple round-robin queue
  const sprites = new Set();           // currently on screen

  // 4) Utilities
  const rand = (a,b) => a + Math.random()*(b-a);
  const choice = (arr) => arr[Math.floor(Math.random()*arr.length)];

  // Spawn scheduler – keep 5 running
  function tickSpawner() {
    while (sprites.size < MAX_ON_SCREEN) spawnOne(nextSrc());
  }
  function nextSrc() {
    const src = queue.shift();
    queue.push(src);
    return src;
  }

  // One RAF loop for all sprites (better perf)
  let lastT = 0;
  function raf(t) {
    if (!lastT) lastT = t;
    const dt = Math.min(64, t - lastT) / 1000;  // seconds; clamp for tab switch
    lastT = t;

    const W = window.innerWidth, H = window.innerHeight;
    sprites.forEach(s => s.update(dt, W, H));
    requestAnimationFrame(raf);
  }

  class Sprite {
    constructor(src) {
      // DOM
      this.el = document.createElement('div');
      this.el.className = 'blob-wrap entering';
      this.el.style.width = 'clamp(160px, 22vmin, 320px)';

      // img + controls
      this.el.innerHTML = `
        <img class="blob" src="${src}" alt="" draggable="false"/>
        <div class="controls">
          <button class="btn-icon btn-pin"   title="Pin"><i class="bi bi-pin-angle-fill"></i></button>
          <button class="btn-icon btn-x"     title="Explode"><i class="bi bi-x-circle"></i></button>
          <button class="btn-icon btn-check" title="Celebrate"><i class="bi bi-check-circle-fill"></i></button>
        </div>
      `;
      LAYER.appendChild(this.el);

      // physics
      const side = choice(['left','right','top','bottom']);       // start off-screen
      const w = this.el.offsetWidth, h = this.el.offsetHeight;
      if (side === 'left')  { this.x = -w;              this.y = rand(EDGE_PAD, H-EDGE_PAD); }
      if (side === 'right') { this.x = W + w;           this.y = rand(EDGE_PAD, H-EDGE_PAD); }
      if (side === 'top')   { this.x = rand(EDGE_PAD, W-EDGE_PAD); this.y = -h; }
      if (side === 'bottom'){ this.x = rand(EDGE_PAD, W-EDGE_PAD); this.y = H + h; }

      // aim roughly toward center
      const cx = W/2, cy = H/2;
      const angle = Math.atan2(cy - this.y, cx - this.x) + rand(-0.6, 0.6);
      this.vx = Math.cos(angle) * BASE_SPEED;
      this.vy = Math.sin(angle) * BASE_SPEED;

      this.boostUntil = 0;
      this.pinned = false;
      this.alive = true;
      this.nextNudge = performance.now() + rand(1000, 2500);

      // rotation (random speed)
      const spinSec = rand(16, 32).toFixed(1);
      this.el.querySelector('.blob').style.animation = `slowSpin ${spinSec}s linear infinite`;
      this.el.style.left = `${this.x}px`; this.el.style.top = `${this.y}px`;
      this.el.style.transform = 'translate(-50%,-50%)';

      // lifetime (auto-despawn unless pinned)
      this.killAt = performance.now() + rand(...LIFETIME_MS);

      // controls
      const pinBtn   = this.el.querySelector('.btn-pin');
      const xBtn     = this.el.querySelector('.btn-x');
      const checkBtn = this.el.querySelector('.btn-check');

      // stop bubbling to drag / window
      [pinBtn, xBtn, checkBtn].forEach(btn => btn.addEventListener('click', e => e.stopPropagation()));

      pinBtn.addEventListener('click', () => {
        this.pinned = !this.pinned;
        pinBtn.classList.toggle('active', this.pinned);
        if (this.pinned) this.killAt = Infinity; // don’t auto-despawn while pinned
        else this.killAt = performance.now() + rand(...LIFETIME_MS);
      });

      xBtn.addEventListener('click', () => this.explode());

      checkBtn.addEventListener('click', () => {
        createConfetti(this.center());
        if (!this.pinned) this.boostUntil = performance.now() + 2200;
      });

      // drag to reposition (pins it)
      let dragging = false, dx = 0, dy = 0;
      this.el.addEventListener('pointerdown', (e) => {
        if (e.target.closest('.controls')) return;
        dragging = true; this.el.setPointerCapture(e.pointerId);
        const r = this.el.getBoundingClientRect();
        dx = e.clientX - (r.left + r.width/2);
        dy = e.clientY - (r.top  + r.height/2);
      });
      window.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        this.pinned = true; pinBtn.classList.add('active');
        this.x = e.clientX - dx; this.y = e.clientY - dy;
        this.applyTransform();
      });
      window.addEventListener('pointerup', () => dragging = false);

      // remove entrance class after anim
      setTimeout(() => this.el.classList.remove('entering'), 650);
    }

    applyTransform() {
      this.el.style.left = `${this.x}px`;
      this.el.style.top  = `${this.y}px`;
      this.el.style.transform = 'translate(-50%,-50%)';
    }

    update(dt, W, H) {
      if (!this.alive) return;

      // auto-despawn
      if (!this.pinned && performance.now() > this.killAt) {
        this.fadeOut();
        return;
      }

      if (!this.pinned) {
        const now = performance.now();
        const speed = now < this.boostUntil ? BASE_SPEED * BOOST_MULT : BASE_SPEED;

        // normalize v to speed
        const len = Math.hypot(this.vx, this.vy) || 1;
        this.vx = (this.vx / len) * speed;
        this.vy = (this.vy / len) * speed;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // edges
        const minX = EDGE_PAD, maxX = W - EDGE_PAD;
        const minY = EDGE_PAD, maxY = H - EDGE_PAD;

        if (this.x < minX) { this.x = minX; this.vx = Math.abs(this.vx); }
        if (this.x > maxX) { this.x = maxX; this.vx = -Math.abs(this.vx); }
        if (this.y < minY) { this.y = minY; this.vy = Math.abs(this.vy); }
        if (this.y > maxY) { this.y = maxY; this.vy = -Math.abs(this.vy); }

        // gentle nudge
        if (now > this.nextNudge) {
          const a = rand(-Math.PI/4, Math.PI/4);
          const c = Math.cos(a), s = Math.sin(a);
          const nx = this.vx * c - this.vy * s;
          const ny = this.vx * s + this.vy * c;
          this.vx = nx; this.vy = ny;
          this.nextNudge = now + rand(1000, 2500);
        }

        this.applyTransform();
      }
    }

    center() {
      const r = this.el.getBoundingClientRect();
      return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }

    explode() {
      if (!this.alive) return;
      this.alive = false;
      createExplosion(this.center());
      this.el.style.transition = 'transform 260ms ease, opacity 260ms ease, filter 260ms ease';
      this.el.style.opacity = '0';
      this.el.style.transform = 'translate(-50%,-50%) scale(0.6) rotate(8deg)';
      this.el.style.filter = 'blur(2px)';
      setTimeout(() => this.destroy(), 280);
    }

    fadeOut() {
      if (!this.alive) return;
      this.alive = false;
      this.el.style.transition = 'opacity 220ms ease';
      this.el.style.opacity = '0';
      setTimeout(() => this.destroy(), 230);
    }

    destroy() {
      sprites.delete(this);
      this.el.remove();
      // make room for a new one
      setTimeout(tickSpawner, 50);
    }
  }

  function spawnOne(src) {
    const s = new Sprite(src);
    sprites.add(s);
  }

  // Effects reused from your previous script
  function createExplosion({x, y}) {
    const pieces = 18;
    for (let i=0;i<pieces;i++){
      const el = document.createElement('div');
      el.className = 'particle';
      const size = 6 + Math.random()*10;
      el.style.width = `${size}px`;
      el.style.height = `${size}px`;
      el.style.borderRadius = '50%';
      el.style.background = `hsl(${Math.floor(Math.random()*40)+330} 90% 60%)`;
      el.style.left = `${x - size/2}px`;
      el.style.top  = `${y - size/2}px`;
      document.body.appendChild(el);

      const ang = Math.random()*Math.PI*2;
      const dist = 80 + Math.random()*140;
      const tx = Math.cos(ang)*dist;
      const ty = Math.sin(ang)*dist;
      el.animate(
        [
          { transform:`translate(0,0) scale(1)`, opacity:1 },
          { transform:`translate(${tx}px,${ty}px) scale(${0.6 + Math.random()*0.6})`, opacity:0 }
        ],
        { duration: 600 + Math.random()*300, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards' }
      ).onfinish = () => el.remove();
    }
  }

  function createConfetti({x, y}) {
    const count = 60;
    for (let i=0;i<count;i++){
      const el = document.createElement('div');
      el.className = 'confetti';
      const w = 6 + Math.random()*6, h = 10 + Math.random()*10;
      el.style.width = `${w}px`; el.style.height = `${h}px`;
      el.style.background = `hsl(${Math.floor(Math.random()*360)} 90% 55%)`;
      el.style.left = `${x - w/2}px`; el.style.top = `${y - h/2}px`;
      el.style.transform = `rotate(${Math.random()*360}deg)`;
      el.style.borderRadius = `${Math.random()<0.5 ? 2 : 0}px`;
      document.body.appendChild(el);

      const dx = (Math.random()*2 - 1) * 160;
      const dy = 220 + Math.random()*220;
      const rot = (Math.random()*720 - 360);

      el.animate(
        [
          { transform:`translate(0,0) rotate(0deg)`, opacity:1 },
          { transform:`translate(${dx}px, ${dy}px) rotate(${rot}deg)`, opacity:0 }
        ],
        { duration: 1300 + Math.random()*700, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards' }
      ).onfinish = () => el.remove();
    }
  }

  // Kick things off
  tickSpawner();
  requestAnimationFrame(raf);

  // keep population after resizes
  window.addEventListener('resize', () => setTimeout(() => sprites.forEach(s => s.applyTransform()), 50));
})();
</script>


</body>
</html>
